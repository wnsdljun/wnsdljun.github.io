1주차 강의를 들으면서 궁금했던 것들을 정리했다.

1. GetComponent<T>()  
   GetComponent() 라는 메서드가 있나보다. 꺽쇠가 무엇을 의미하는지 다시 알게 되었다. "\<T\>" 라는것이 제네릭이란 것인데...  
  컴포넌트는 여러 종류가 있으니 그중 어떤 것을 골라올지를 알려주는것이다. 만약 같은 종류의 컴포넌트들을 가져와야한다면 GetComponents() 가 있고,
  비 제네릭 방식도 있는데 이거는 컴포넌트 형식으로 반환해서 원하는 컴포넌트 타입으로 캐스팅해줘야 쓸 수 있다.
```C#
Component component = GetComponent(typeof(SpriteRenderer));
renderer = component as SpriteRenderer;
```
  특수한 경우에만 사용된다고.

2. 그렇다면 어째서 transform은 바로 이용이 가능했는데, SpriteRenderer는 불러와서 이용해야했는가?  
   간단하다. transform은 모든 오브젝트가 갖는 기본적인 컴포넌트라 그렇다.

3. 좌우 반전에서 transform.scale 에 -1를 곱해서 좌우 반전을 시키면 안되는지?  
   되기는 하나, 오브젝트에 이런저런 컴포넌트가 많이 들어가 있으면 오류가 생길수도 있다고 한다.  
   그리고 좌우반전을 시킨다는 의도가 명확하게 전달이 되지 않는다는 문제가 있다.

4. play 모드에서 수정된 사항은 적용되지 않음  
   이 부분은 주의가 필요하다. 수정된 사항을 적용시켜야 할 때가 있고, 아닐 때도 있고..  
   에셋도 있고, 컴포넌트 값을 복사-붙여넣는 방법도 있고 프리팹화해서 임시로 저장? 할 수도 있다.

5. InvokeRepeating()  
   이 메서드는 string 타입으로 메서드 이름을 받아 그 메서드를 일정 시간 이후에, 얼마만큼의 시간 간격마다 호출하는 기능을 갖고있다.  
   어떻게 문자열로 메서드를 호출할 수 있는지가 궁금했다. 이는 C#의 Reflection 기능을 이용한 것이라고.  
   자세한 부분은 너무 복잡하여 추상적으로만 이해하였다.  
   참조, 검사, 참조, 실행. 때문에 과하게 반복적으로 사용하는 경우 리소스를 많이 소모하므로 다른 방식을 이용하는것이 추천된다.  
   그리고 문자열이다 보니 컴파일러가 이를 잡아주지 못한다는 단점이 있어 주의해야한다.
   
6. 버튼 OnClick에 오브젝트 연결  
   오브젝트에 스크립트를 연결하고, 그 오브젝트를 버튼 컴포넌트에 연결해서 메서드를 호출해야한다.
   오브젝트 없이, 스크립트만 연결하면 MonoScript.name 라는 칸과 그 밑에 문자열 타입으로 무언갈 입력할 수 있을것으로 보이는데, 오브젝트 연결 없이 스크립트만 연결해서 코드 한 줄 동작시키는것은 불가능한것인가?
